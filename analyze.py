#!/usr/bin/env python3
"""
Script to analyze logs generated by the asynchronous distributed system.
It reads log files (each with entries formatted as:
  <system time> | <event type> | LC: <logical_clock> | <details>
),
parses them, and produces graphs for:
  - Logical clock vs. system time
  - Histogram of logical clock jump sizes
  - Message queue length vs. system time

To compare different simulation configurations (e.g. wide vs. narrow clock rate variation
or different probabilities for internal events), run the simulation with those parameters,
store the logs in separate folders, and then point this script to each log folder.
"""

import os
import re
import glob
import argparse
import pandas as pd
import matplotlib.pyplot as plt

def parse_log_line(line):
    """
    Parse a log line into a dictionary.
    Expected format:
      <system time> | <event type> | LC: <logical_clock> | <details>
    """
    parts = line.split('|')
    if len(parts) < 3:
        return None
    try:
        timestamp = float(parts[0].strip())
    except ValueError:
        return None
    event_type = parts[1].strip()
    lc_part = parts[2].strip()
    # Extract the logical clock value after "LC:"
    lc_match = re.search(r'LC:\s*(\d+)', lc_part)
    logical_clock = int(lc_match.group(1)) if lc_match else None
    details = parts[3].strip() if len(parts) > 3 else ''
    # Optionally, extract queue length from details (if present)
    queue_len = None
    if "QueueLen:" in details:
        queue_match = re.search(r'QueueLen:\s*(\d+)', details)
        if queue_match:
            queue_len = int(queue_match.group(1))
    return {
        'timestamp': timestamp,
        'event_type': event_type,
        'logical_clock': logical_clock,
        'details': details,
        'queue_length': queue_len
    }

def load_log_file(filepath):
    """
    Load a log file and return a DataFrame.
    """
    with open(filepath, 'r') as f:
        lines = f.readlines()
    records = []
    for line in lines:
        parsed = parse_log_line(line)
        if parsed:
            records.append(parsed)
    if records:
        df = pd.DataFrame(records)
        df.sort_values('timestamp', inplace=True)
        return df
    else:
        return pd.DataFrame()

def plot_logical_clock(df, title='Logical Clock vs. System Time', label=None):
    """
    Plot the logical clock value over system time.
    """
    plt.figure(figsize=(10, 6))
    plt.plot(df['timestamp'], df['logical_clock'], marker='o', linestyle='-', label=label)
    plt.xlabel('System Time (s)')
    plt.ylabel('Logical Clock Value')
    plt.title(title)
    if label:
        plt.legend()
    plt.grid(True)
    plt.show()

def plot_queue_length(df, title='Message Queue Length vs. System Time'):
    """
    Plot the message queue length over system time (if available).
    """
    if df['queue_length'].dropna().empty:
        print("No queue length data available in this log.")
        return
    plt.figure(figsize=(10, 6))
    plt.plot(df['timestamp'], df['queue_length'], marker='o', linestyle='-', color='orange')
    plt.xlabel('System Time (s)')
    plt.ylabel('Message Queue Length')
    plt.title(title)
    plt.grid(True)
    plt.show()

def plot_clock_jump_histogram(df, title='Histogram of Logical Clock Jumps'):
    """
    Calculate and plot a histogram of differences between consecutive logical clock values.
    """
    df_sorted = df.sort_values('timestamp')
    df_sorted['clock_diff'] = df_sorted['logical_clock'].diff()
    plt.figure(figsize=(10, 6))
    plt.hist(df_sorted['clock_diff'].dropna(), bins=range(0, int(df_sorted['clock_diff'].max())+2), edgecolor='black')
    plt.xlabel('Jump Size')
    plt.ylabel('Frequency')
    plt.title(title)
    plt.grid(True)
    plt.show()

def calculate_clock_rate(df):
    """
    Estimate the clock rate (increments per second) over the simulation period.
    """
    df_sorted = df.sort_values('timestamp')
    total_time = df_sorted['timestamp'].iloc[-1] - df_sorted['timestamp'].iloc[0]
    total_increments = df_sorted['logical_clock'].iloc[-1] - df_sorted['logical_clock'].iloc[0]
    if total_time > 0:
        return total_increments / total_time
    return 0

def analyze_logs(directory):
    """
    Process all .log files in the given directory and plot graphs for each.
    Also prints summary statistics such as estimated clock rate.
    """
    log_files = glob.glob(os.path.join(directory, '*.log'))
    if not log_files:
        print("No log files found in the directory:", directory)
        return

    machine_data = {}
    for filepath in log_files:
        df = load_log_file(filepath)
        if df.empty:
            continue
        machine_name = os.path.basename(filepath)
        machine_data[machine_name] = df
        print(f"Loaded {len(df)} entries from {machine_name}")
        rate = calculate_clock_rate(df)
        print(f"Estimated clock rate for {machine_name}: {rate:.2f} increments/second")
        # Plot graphs for this machine
        plot_logical_clock(df, title=f'Logical Clock vs. System Time ({machine_name})', label=machine_name)
        plot_clock_jump_histogram(df, title=f'Logical Clock Jump Histogram ({machine_name})')
        plot_queue_length(df, title=f'Message Queue Length vs. System Time ({machine_name})')

    # If multiple machines are present, create a combined plot for logical clock trends.
    if len(machine_data) > 1:
        plt.figure(figsize=(10, 6))
        for name, df in machine_data.items():
            plt.plot(df['timestamp'], df['logical_clock'], marker='o', linestyle='-', label=name)
        plt.xlabel('System Time (s)')
        plt.ylabel('Logical Clock Value')
        plt.title('Comparison of Logical Clocks Across Machines')
        plt.legend()
        plt.grid(True)
        plt.show()

def main():
    parser = argparse.ArgumentParser(description="Analyze distributed system log files")
    parser.add_argument("--logdir", type=str, required=True,
                        help="Directory containing the .log files from the virtual machines")
    args = parser.parse_args()
    analyze_logs(args.logdir)

if __name__ == '__main__':
    main()
